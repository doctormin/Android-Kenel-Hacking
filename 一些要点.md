## module的一些特点
在文件的最后，我们调用 module_init 和 module_exit 来告诉内核哪个是加载函数，哪个是卸载函数。这样我们可以按自己喜好对函数自由命名。


+ 给启动函数和终止函数加上了__init 和 __exit

## real parent vs. parent in task_struct

## finding `pid_t first_child_pid`;
I search in \include\linux\list.h:
```
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
}
```
And in `task_struct`:
```
	struct list_head children;	/* list of my children */
```
which means it needs `list_empty(&(tar->children))` which will return 1 if there is no children

And to fetch the youngest children, we need to locate the first element of the linked list whose head node is `tar->children`, and I search in the `list.h`:
```
/**
 * list_first_entry - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_struct within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_first_entry(ptr, type, member) \
	list_entry((ptr)->next, type, member)
```
Cool!  So this means we have 2 choices:
+ `list_first_entry(&(task->children), struct task_struct, siblings)->pid`
+ `list_entry((task->children).next, struct task_struct, siblings)->pid`

## choose `sibling` or `children`?
### Background:
I want to carry out a DFS iteration in the process tree:
+ DFS(root)
  + iterating root's sibling
  + for every sibling `node` do `DFS(node)`
### Problem encountered
Here is part of my DFS function:
```
struct list_head* iterator;
struct task_struct* next_node; 
//iterating through all the children of the root
list_fot_each(iterator, &(root->children)){
    next_node = list_entry(iterator, struct task_struct, children);
    DFS(next_node, buf, nr);
}
```
There is an error caused by:
```
next_node = list_entry(iterator, struct task_struct, children);
```
### Solution
The third parameter for `list_entry()` stands for **"the variable name of `iterator` in `task_struct`"**. But unfortunatly, `list_fot_each(iterator, &(root->children))`makes it confusing about the indentification of `iterator` in its `task_struct`.**Is it `children` or `sibling`?**
```
struct list_head children;	/* list of my children */
struct list_head sibling;	/* linkage in my parent's children list */
```
The answer is **sibling**.
#### Intuitive Reason:
We just need to realize that when DFS is iterating in the for loop --- `list_for_each(next_node...)`, it is actually iterating through the **siblings** of the `next_node`. So the correct code is:
```
struct task_struct* next_node; 
next_node = list_entry(iterator, struct task_struct, sibling);
```
#### More Convincing Reason:
We can find the definision of `list_for_each` in `list.h`:
```
#define list_for_each(pos, head) \
	      for (pos = (head)->next; pos != (head); pos = pos->next)
```
so the original loop can be written as:
```
for(iterator = (root->children).next; iterator !=(root->children).next; iterator = iterator->next) {
    next_node = list_entry(iterator, struct task_struct, sibling);
    DFS(next_node, buf, nr);
}
```
It's obvious that `iterator = interator->next` **means moving to the next sibling** (according to DFS algorithm)!
## Why `execl("ptree_test", NULL)` can't work?
```
else if (child == 0) //in the child process
	{
		printf("518030910188-Child is %d\n", getpid());
		if(execl("./ptree_test",  NULL) == -1){
            //!exception
            printf("calling ptree_test failed in child process!\n");
        }
		_exit(0);
	}
```
Well, this is a problem I encountered in problem 3. We need to run the function we implemented in problem 2 --- `ptree_test`. It turns out that the `ptree_test` can not work properly(giving no ouput) but the exception doesn't happen either.
### Solution
Back to the definition of `execl( )`:
```
int execl(const char *path, const char * arg..)
````
And:
+ path is the path of programme called
+ following parameters are argv[]
+ **argv[0] by default is the place saving the name of the programme**
 
So it seems that the problem is caused by the missing programme name.
But why? Why this hinders `ptree_test` from printing anything?

We can find the definition in `unistd.h`
```
/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (const char *__path, const char *__arg, ...)
     __THROW __nonnull ((1, 2));
```
I think it's reseanable to defer that `__THROW __nonnull ((1, 2));` means the first two parameters can not be null.