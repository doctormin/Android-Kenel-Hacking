## module的一些特点
在文件的最后，我们调用 module_init 和 module_exit 来告诉内核哪个是加载函数，哪个是卸载函数。这样我们可以按自己喜好对函数自由命名。


+ 给启动函数和终止函数加上了__init 和 __exit

## real parent vs. parent in task_struct

## finding `pid_t first_child_pid`;
I search in \include\linux\list.h:
```
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
}
```
And in `task_struct`:
```
	struct list_head children;	/* list of my children */
```
which means it needs `list_empty(&(tar->children))` which will return 1 if there is no children

And to fetch the youngest children, we need to locate the first element of the linked list whose head node is `tar->children`, and I search in the `list.h`:
```
/**
 * list_first_entry - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_struct within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_first_entry(ptr, type, member) \
	list_entry((ptr)->next, type, member)
```
Cool!  So this means we have 2 choices:
+ `list_first_entry(&(task->children), struct task_struct, siblings)->pid`
+ `list_entry((task->children).next, struct task_struct, siblings)->pid`